# HSR vs earlyZ



#### earlyz

当不透明的图元从Rasterize阶段开始逐像素进行处理时，首先进行Depth Read & Test，通过后直接Write，后续再执行该像素上的PS程序

是需要渲染不透明物体时要按从近到远的顺序去绘制\(或者三角形由远到近\)，因为近处的物体先绘制好之后，其写入的深度会阻挡住后面物体的ZTest，也就避免了后面物体无意义的渲染开销

这个排序只能做到大致上准确，做不到完全准确。比如你有两个三角形A、B交叉在一起，互有遮挡，那你不论怎么排序都会产生先完全绘制一个三角形，再绘制另外一个

还有一种方法能完全剔除，是预渲染zbuffer，但这种方法有预渲染zbuffer的开销

### HSR

iOS TBDR架构的HSR确保遮挡像素肯定不会被draw

hsr起作用的阶段是在光栅化生成所有fragment之后，（这个跟ealry-z相似），但是这个hsr会打断后面的着色流程（也就是说他会打断渲染管线，光栅化完成的图元不会马上进入fragmentShader阶段，而是会等待所有的图元全部光栅化完成），这个时候所有的fragment已经生成，并且里面通过插值都已经得到了深度值，hsr可以从里面筛选出实际有效的fragment，所以说hsr是可以彻底解决不透明物体的overdraw问题。

 TBDR 都是将PS的处理延后到了处理完所有VS之后，而不是像IMR一样VS后马上PS**所以说TBR架构也是个延迟渲染架构。**

HSR是怎么处理AlphaTest和AlphaBlend的。HSR在设计原理上高到飞起，但前提是假定了前面的物体会挡住后面的物体，因此对于AlphaTest和AlphaBlend物体都是没有作用的（但他俩仍然可以被EarlyZ拦住）。不仅没作用，反而会被其中断Defer流程，导致渲染性能降低。

