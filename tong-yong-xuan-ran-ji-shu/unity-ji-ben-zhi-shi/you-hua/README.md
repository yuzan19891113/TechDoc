# 性能分析

**1. CPU**   
CPU经常受限于需要渲染的**批次\(batches\)数量**。因为CPU每次需要为渲染准备以及收集数据，然后调用GPU图形处理接口，这个过程是相当耗时费力的。   
因此Unity 提供了一个非常好用的工具——**Statistics Window面板**。   
可以通过 **Statistics面板** 检查正在渲染的 **batches**数量，如果数量过高，那么意味着CPU的消耗过高。

* **DrawCalls**

1. 使用Draw Call Batching，也就是描绘调用批处理。Unity在运行时可以将一些物体进行合并，从而用一个描绘调用来渲染他们。具体下面会介绍。
2. 通过把纹理打包成图集来尽量减少材质的使用。
3. 尽量少的使用反光啦，阴影啦之类的，因为那会使物体多次渲染。

* **物理组件（Physics）**

1.设置一个合适的Fixed Timestep。设置的位置如图：  
  


![](http://mmbiz.qpic.cn/mmbiz/KcTgPicibiaNTgicw38jVP98EGganMeSrps78pqWENSRQuleyxYZk6ibDcNTud7qibvUHUQELYvKBib79TfbXHZWBp0Rw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1)

  
　　那何谓“合适”呢？首先我们要搞明白Fixed Timestep和物理组件的关系。物理组件，或者说游戏中模拟各种物理效果的组件，最重要的是什么呢？计算啊。对，需要通过计算才能将真实的物理效果展 现在虚拟的游戏中。那么Fixed Timestep这货就是和物理计算有关的啦。所以，若计算的频率太高，自然会影响到CPU的开销。同时，若计算频率达不到游戏设计时的要求，有会影响到 功能的实现，所以如何抉择需要各位具体分析，选择一个合适的值。  
  
　　2.就是不要使用网格碰撞器（mesh collider）：为啥？因为实在是太复杂了。网格碰撞器利用一个网格资源并在其上构建碰撞器。对于复杂网状模型上的碰撞检测，它要比应用原型碰撞器精 确的多。标记为凸起的（Convex ）的网格碰撞器才能够和其他网格碰撞器发生碰撞。各位上网搜一下mesh collider的图片，自然就会明白了。我们的手机游戏自然无需这种性价比不高的东西。

* **GC**

在CPU的部分聊GC，感觉是不是怪怪的？其实小匹夫不这么觉得，虽然GC是用来处理内存的，但的确增加的是CPU的开销。因此它的确能达到释放内存的效果，但代价更加沉重，会加重CPU的负担，因此对于GC的优化目标就是尽量少的触发GC。

首先我们要明确所谓的GC是Mono运行时的机制，而非Unity3D游戏引擎的机制，所以GC也主要是针对Mono的对象来说的，而它管理的也是 Mono的托管堆。 搞清楚这一点，你也就明白了GC不是用来处理引擎的assets（纹理啦，音效啦等等）的内存释放的，因为U3D引擎也有自己的内存堆而不是和Mono一 起使用所谓的托管堆。

其次我们要搞清楚什么东西会被分配到托管堆上？不错咯，就是引用类型咯。比如类的实例，字符串，数组等等。而作为int，float，包括结构体struct其实都是值类型，它们会被分配在堆栈上而非堆上。所以我们关注的对象无外乎就是类实例，字符串，数组这些了。

那么GC什么时候会触发呢？两种情况：

1.首先当然是我们的堆的内存不足时，会自动调用GC。

2.其次呢，作为编程人员，我们自己也可以手动的调用GC。

所以为了达到优化CPU的目的，我们就不能频繁的触发GC。而上文也说了GC处理的是托管堆，而不是Unity3D引擎的那些资源，所以GC的优化说白了也就是代码的优化。那么匹夫觉得有以下几点是需要注意的：

1.字符串连接的处理。因为将两个字符串连接的过程，其实是生成一个新的字符串的过程。而之前的旧的字符串自然而然就成为了垃圾。而作为引用类型的字符串，其空间是在堆上分配的，被弃置的旧的字符串的空间会被GC当做垃圾回收。

2.尽量不要使用foreach，而是使用for。foreach其实会涉及到迭代器的使用，而据传说每一次循环所产生的迭代器会带来24 Bytes的垃圾。那么循环10次就是240Bytes。

3.不要直接访问gameobject的tag属性。比如if \(go.tag == “human”\)最好换成if \(go.CompareTag \(“human”\)\)。因为访问物体的tag属性会在堆上额外的分配空间。如果在循环中这么处理，留下的垃圾就可想而知了。

4.使用“池”，以实现空间的重复利用。

5.最好不用LINQ的命令，因为它们会分配临时的空间，同样也是GC收集的目标。而且我很讨厌LINQ的一点就是它有可能在某些情况下无法很好的进 行AOT编译。比如“OrderBy”会生成内部的泛型类“OrderedEnumerable”。这在AOT编译时是无法进行的，因为它只是在 OrderBy的方法中才使用。所以如果你使用了OrderBy，那么在IOS平台上也许会报错。

* **代码使用问题**

1.以物体的Transform组件为例，我们应该只访问一次，之后就将它的引用保留，而非每次使用都去访问。这里有人做过一个小实验，就是对比通过 方法GetComponent&lt;Transform&gt;\(\)获取Transform组件, 通过MonoBehavor的transform属性去取，以及保留引用之后再去访问所需要的时间：  


* GetComponent = 619ms
* Monobehaviour = 60ms
* CachedMB = 8ms
* Manual Cache = 3ms

  
　　2.如上所述，最好不要频繁使用GetComponent，尤其是在循环中。  
  
　　3.善于使用OnBecameVisible\(\)和OnBecameVisible\(\),来控制物体的update\(\)函数的执行以减少开销。  
  
　　4.使用内建的数组，比如用Vector3.zero而不是new Vector\(0, 0, 0\);  
  
　　5.对于方法的参数的优化：善于使用ref关键字。值类型的参数，是通过将实参的值复制到形参，来实现按值传递到方法，也就是我们通常说的按值传递。 复制嘛，总会让人感觉很笨重。比如Matrix4x4这样比较复杂的值类型，如果直接复制一份新的，反而不如将值类型的引用传递给方法作为参数。



**2. GPU**   
GPU往往受限于在渲染时像素的填充率以及现存带宽的使用。   
如何来检查并定位Unity给出的针对填充率是这样检查的：   
Lower the display resolution and run the game. If a lower display resolution makes the game run faster, you may be limited by fillrate on the GPU.   
降低游戏的分辨率然后运行，如果在低分辨率的情况下，游戏的运行非常流畅，那么可能在GPU上受到的像素填充率的影响。   
Unity同样也提供了一个很好用的工具，来便于我们进行优化—— **FrameDebugger**。

**二、不常见的问题及检查方法：**   
1. **CPU**   
如果在渲染时CPU需要处理太多的**顶点\(vertex\)**，情况如处理**skinned meshes**\(蒙皮网格：用于骨骼动画等\)、**cloth simulation**\(布料仿真\)、**particles system**\(粒子系统\)以及一些游戏里面的**gameObject**和**网格**\(Mesh\)。   
针对于上面的情况，通常在不影响游戏的质量的情况下，尽量保持定点数越低越好，这样才能尽可能的保持CPU的流畅性。针对于此，后面文章会介绍。   
2. **GPU**   
如果在渲染时，GPU也要去处理太多的顶点数据\(Vetex Data\)。   
此时在确保游戏的流畅性的情况下，可以接受的顶点数据的总数，取决于**GPU性能和顶点着色器\(Vertex Shader\)的复杂性**。   
为此Unity给出的Tips：   
针对于**移动设备**，尽量当前每帧渲染**顶点数不要超过十万个**。   
针对于**PC设备**,尽管PC设备的性能优于移动设备，也能更好的处理顶点数据，甚至能同时处理几百万个，但是仍然可以通过优化这个，然后仍然可以获得一个非常好的额实际性能效果。   
3. **Garbage Collection\(GC 垃圾回收\)或者Physics**   
如果渲染时，通过检查定位，发现其实影响性能的并非是因为CPU的Batches或者GPU引起的，那么，这个问题可能出GC或者Physics（物理计算）。



###  <a id="cpu&#x51CF;&#x5C11;draw-call"></a>

