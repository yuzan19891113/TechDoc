# 静态合批vs 动态合批

**Dynamic Batching\(动态批处理\)**： 

Unity3D的draw call动态批处理机制是引擎自动进行的，无需像静态批处理那样手动设置static。我们举一个动态实例化prefab的例子，如果动态物体共享相同的 材质，则引擎会自动对draw call优化，也就是使用批处理。

对于在那些小的零散的Mesh，CPU将会对Mesh的顶点进行转换，动态的将他们组合在一起，并且通知GPU将他们一次绘制出来。 

**动态批处理被打断：**

1.批处理动态物体需要在每个顶点上进行一定的开销，所以动态批处理仅支持小于900顶点的网格物体。

2.如果你的着色器使用顶点位置，法线和UV值三种属性，那么你只能批处理300顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1和切向量，那你只能批处理180顶点以下的物体。

3.不要使用缩放。分别拥有缩放大小\(1,1,1\) 和\(2,2,2\)的两个物体将不会进行批处理。

4.统一缩放的物体不会与非统一缩放的物体进行批处理。

5.使用缩放尺度\(1,1,1\) 和 \(1,2,1\)的两个物体将不会进行批处理，但是使用缩放尺度\(1,2,1\) 和\(1,3,1\)的两个物体将可以进行批处理。

6.使用不同材质的实例化物体（instance）将会导致批处理失败。

7.拥有lightmap的物体含有额外（隐藏）的材质属性，比如：lightmap的偏移和缩放系数等。所以，拥有lightmap的物体将不会进行批处理（除非他们指向lightmap的同一部分）。

8.多通道的shader会妨碍批处理操作。比如，几乎unity中所有的着色器在前向渲染中都支持多个光源，并为它们有效地开辟多个通道。

9.预设体的实例会自动地使用相同的网格模型和材质。

10.update vertice buffer in job system

11.对于特效不一定能合批，因为特效一般按照绘制距离排序，可以都改为2500， Unity对Opaque的队列定义为2000，Transparent的队列定义为3000，2500以下的自定义队列都是不按照距离排序的。所以都修改为2500就可以达到目的

  
**Static Batching\(静态批处理\)**：

你只需要明确指出哪些物体是静止的，并且在游戏中永远不会移动、旋转和缩放。想完成这一步，你只需要在检测器（Inspector）中将Static复选框打勾即可，

将一些不会移动并且不会发生改变的物体通过Static合并成一张大的网格，这样可以使他们渲染起来更快。



### 共同点

* 需要材质相同

### 不同点

* 静态合批会在绘制前创建新的mesh，动态合批不会创建，只是共有顶点和索引缓冲区

#### 缺点

* 静态批处理，可能导致更多的内存消耗，因为需要在内存中组成一个大的网格镜像  
* 动态批处理，会导致更多CPU的开销，因为需要去重新计算每个网格的顶点位置并重新计算生成一张大的网格数据









