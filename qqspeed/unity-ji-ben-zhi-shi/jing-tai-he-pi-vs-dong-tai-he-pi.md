# 静态合批vs 动态合批

**Dynamic Batching\(动态批处理\)**： 

对于在那些小的零散的Mesh，CPU将会对Mesh的顶点进行转换，动态的将他们组合在一起，并且通知GPU将他们一次绘制出来。 

动态批处理被打断：

* 动态批处理网格的时候因为是逐顶点进行处理的，所以在这方面是有一定的消耗。所以**Unity限制动态批处理只适用于合并后的网格顶点在900以下**\(比如两个网格虽然使用了相同材质和纹理，但是两个网格顶点总数超过了900此种情况就不会进行批处理\)。但是如果除了**顶点坐标以外我们还使用了法线以及UV坐标**，那么这个900就要除以3变成300了，如果我们在着色器\(Shader\)中使用了**顶点坐标、法线、UV0、UV1以及切线**，那么这个总数就只能是180了。但是随着硬件设备性能的提升未来这个数值肯定会发生改变的。 
*  **缩放会打断批处理**，比如相同物体才场景中进行了复制，其中一个的scale是\(1,1,1\)，一个的scale是 \(-1,-1,-1\)，这种情况下，Unity是不会进行动态批处理的。 
* _我们在处理使用 **lightmap** 的物体的时候如果有额外渲染参数设置也会打断批处理：比如在 lightmap 包含了 **lightmap index 和 offset/scale**。简单的来说使用动态光照的物体，在用lightmap时如果需要批处理，那么必须使用完全一样的lightmap location。\(此处暂时不是很理解，回头学习光照的时候会重新补充，暂时标记\)_ 
*  如果**Shader含有多个pass**\(渲染流水线\)，同样也会打断批处理。 
* 在Unity中几乎所有Shader在使用**Forward Render Path**时都支持多个光照效果，能非常有有效的为他们提供渲染管线来处理。因此这种**per-pixel-light逐像素点计算的光照将不会批处理** 
* 如果使用**Deferred Render Path\(**延时渲染\)，动态批处理将会被禁用，因为延时渲染会固定产生两次Drawcall，来绘制物体**两次。**

  
**Static Batching\(静态批处理\)**：

将一些不会移动并且不会发生改变的物体通过Static合并成一张大的网格，这样可以使他们渲染起来更快。

### 共同点

* 需要材质相同

### 不同点

* 静态合批会在绘制前创建新的mesh，动态合批不会创建，只是共有顶点和索引缓冲区

#### 缺点

* 静态批处理，可能导致更多的内存消耗，因为需要在内存中组成一个大的网格镜像  
* 动态批处理，会导致更多CPU的开销，因为需要去重新计算每个网格的顶点位置并重新计算生成一张大的网格数据









